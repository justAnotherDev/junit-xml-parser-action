"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const xml2js_1 = __importDefault(require("xml2js"));
exports.parse = async (xmlString, xml2jsOptions) => {
    const options = xml2jsOptions !== null && xml2jsOptions !== void 0 ? xml2jsOptions : {
        attrValueProcessors: [xml2js_1.default.processors.parseNumbers]
    };
    const result = await xml2js_1.default.parseStringPromise(xmlString, options);
    if (result['testsuites']) {
        return _parse(result['testsuites']);
    }
    else {
        return _parse(result['testsuite']);
    }
};
const _parse = (objOrArray) => {
    if (Array.isArray(objOrArray)) {
        return objOrArray.map((_obj) => {
            // 中身がさらにネストされた配列 or $キーのobjectなら再起
            if (Array.isArray(_obj) || typeof (_obj) === 'object') {
                return _parse(_obj);
            }
            // 配列の中身が単なる文字列ならinnerキーを自分で付けてobjectで返す
            return { inner: _obj };
        });
    }
    let output = {};
    Object.keys(objOrArray).forEach((key) => {
        const nested = objOrArray[key];
        if (key === '$') {
            output = { ...output, ..._parse(nested) };
        }
        else if (key === 'system-out' || key === 'system-err') {
            output[key] = nested.map((inner) => inner);
        }
        else if (typeof (nested) === 'object') {
            output[key] = _parse(nested);
        }
        else if (key === '_') {
            output['inner'] = nested;
        }
        else {
            output[key] = nested;
        }
    });
    return output;
};
//# sourceMappingURL=index.js.map